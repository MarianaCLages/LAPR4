US 3000
=======================================

# 1. Requisitos

## **Demo:**

As Project Manager, I want the team to specify a grammar allowing to express several kinds of questionnaires.
<br>
<br>

### **AC:**

* 1: The grammar should be conceived having in mind its reusability/applicability on other application domains than the
  one of this project (e.g., pedagogical questionnaires).

### **Respostas no Forum:**

*Ainda nenhuma resposta*

# 2. Análise

The questionnaire must be divided into several parts as stated on the requirements document.


### Questionnaire

| **Field**            | **Description**                                                                       |
|----------------------|---------------------------------------------------------------------------------------|
| **ID**               | Mandatory alphanumeric value to univocally identify a questionnaire.                  |
| **Title**            | The title of the questionnaire. It is a mandatory short sentence                      |
| **Welcome Message**  | An optional message to be presented before any section/question.(accepts line breaks) |
| **List of Sections** | A list of sections that compose the questionnaire.                                    |
| **Final Message**    | An optional message to be presented after all sections/questions.                     |

### Section

| **Field**               | **Description**                                                                                                                                                                                                        |
|-------------------------|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Section ID**          | Mandatory alphanumeric value to univocally identify a section.                                                                                                                                                         |
| **Section Title**       | The title of the section. It is a mandatory short sentence                                                                                                                                                             |
| **Section Description** | An optional message to be presented before any question.(accepts line breaks)                                                                                                                                          |
| **Obligatoriness**      | It might be one of “mandatory”, “optional” or “condition dependent”                                                                                                                                                    |
| **Repeatability**       | Optional condition stating if the questions of this section are to be answered morethan once. At least two kinds of conditions need to be supported: (i) based on numeric answers or (ii) on a set of selected values. |
| **Content**             | Set of questions                                                                                                                                                                                                       |

### Question

| **Field**          | **Description**                                                     |
|--------------------|---------------------------------------------------------------------|
| **Question ID**    | Mandatory alphanumeric value to univocally identify a question.     |
| **Question**       | The question itself. (Free text, no line breaks)                    |
| **Instruction**    | An optional message to be presented before the question.            |
| **Type**           | Defines the kind of answer over the possible types (defined below)  |
| **Obligatoriness** | It might be one of “mandatory”, “optional” or “condition dependent” |
| **Extra Info**     | Optional information to be presented after the question.            |


- Questionary ID, Section ID, Question ID requirements are the same;
- Questionary Title, Section Title requirements are the same;
- Welcoming message, Section Description requirements are the same;
- Both Obligatoriness (Question and Section) requirements are the same;

**We need to take these similarities into account when creating the grammar and try to reuse the same rules.**


### Possible Types

• Free-Text: A free text field that accepts any text.
• Numeric: A numeric field that accepts any number.
• Single-Choice: A single choice field that accepts only one answer.
• Single-Choice with input value: A single choice field that accepts only one answer but the last option is a text field
that accepts any text.
• Multiple-Choice: A multiple choice field that accepts multiple answers.
• Multiple-Choice with input value: A multiple choice field that accepts multiple answers but the last option is a text 
field that accepts any text.
• Sorting Options: given some options, the user must sort them in the desired order.
• Scaling Options: given some options, the user must select a value on a scale.

## Domain Model

![US2001MD](US2001MD.svg)

# 3. Design

## 3.1. Realização da Funcionalidade

### 3.1.1. Warehouse Employee faz o upload do ficheiro JSON para importar a planta.

We are using a layer structure design.:

- Domain Layer:
    - Warehouse
- Application Layer:
    - ImportWarehousePlantController
    - ImportPlantService
- Builder Layer:
    - WarehouseBuilder
- Repository Layer:
    - WarehouseRepository

![US2001SDWarehouseEmployeeImports](US2001SDWarehouseEmployeeImports.svg)

#### How is the Service created?

![CreateService](CreateService.svg)

### 3.1.2. No Start-up do Sistema

Design-wise, importing the plant on start-up is very similar to the previous one. The only difference is that instead
of a UI on the start-up, the system must be able to import the plant from a JSON file if it is not already in the
repository.

## 3.3. Padrões Aplicados

- We used the builder pattern to create the Warehouse because it is an object that is created pass by pass. While
  reading the JSON file, the object is being created and once it's finished reading it is in a correct state and can be
  build.
- We used an application service to read the information from the file and save the Warehouse in the repository. In
  order to be able to be able to dinamically support different file formats, we used the parterns Factory to create
  different services.
- Our full development was always concerning the GRASP patherns (High cohesion, Low coupling),"Tell, don't ask", "
  Single Responsibility Principle".

## 3.4. Testes

**It is crutial to test the builder class since it is the "core" of this use case.**

**Teste 1:** Create an valid Warehouse

```
void simpleWarehouseTest() {
        WarehouseBuilder warehouseBuilder = new WarehouseBuilder()
          .withLength(20)
          .withWidth(30)
          .withSquare(1)
          .withUnit("m")
          .addAgvDock(String.valueOf(1), new Location(5, 4), new Location(5, 5), new Location(6, 6), Accessibility.LENGHT_PLUS)
          .addAgvDock(String.valueOf(2), new Location(10, 4), new Location(10, 5), new Location(10, 6), Accessibility.WIDTH_MINUS)
          .addAisle(1, new Location(0, 1), new Location(0, 6), new Location(3, 3), Accessibility.LENGHT_PLUS)
          .addAisle(2, new Location(10, 15), new Location(10, 20), new Location(15, 15), Accessibility.WIDTH_MINUS)
          .addRow(1, 1, new Location(0, 1), new Location(0, 2), 5)
          .addRow(1, 2, new Location(0, 2), new Location(0, 3), 10)
          .addRow(2, 1, new Location(10, 15), new Location(10, 16), 5)
          .withName("A Simple Warehouse");

        Warehouse warehouse = warehouseBuilder.build();
        assertNotNull(warehouse);
        //aisles
        assertEquals(2, warehouse.aisles().size());
    }
```

**Teste 2:** Try to create an invalid Warehouse, try to associate a row with an aisle that doesn't exist

```
@Test
void tryToAddRowsToAislesThatDontExist() {
WarehouseBuilder warehouseBuilder = new WarehouseBuilder()
.addAgvDock(String.valueOf(1), new Location(5, 4), new Location(5, 5), new Location(6, 6), Accessibility.LENGHT_PLUS)
.addAgvDock(String.valueOf(2), new Location(10, 4), new Location(10, 5), new Location(10, 6), Accessibility.WIDTH_MINUS)
.addAisle(1, new Location(0, 1), new Location(0, 6), new Location(3, 3), Accessibility.LENGHT_PLUS)
.addAisle(2, new Location(10, 15), new Location(10, 20), new Location(15, 15), Accessibility.WIDTH_MINUS)
.addRow(1, 1, new Location(0, 1), new Location(0, 2), 5)
.addRow(1, 2, new Location(0, 2), new Location(0, 3), 10)
.addRow(2, 1, new Location(10, 15), new Location(10, 16), 5)
.withName("No Rows :(");


        Location l1 = new Location(20, 20);
        Location l2 = new Location(20, 21);

        Exception e = Assertions.assertThrows(IllegalArgumentException.class, () -> warehouseBuilder.addRow(3, 2, l1, l2, 10));
        assertEquals("Aisle with id 3 does not exist", e.getMessage());
    }
```

# 4. Implementação

Since one of the requirements was to be able to read the information from a file on the start of the application, we
opted for keeping the path to the file in the application properties. This way, we can change the path to the file. We
use the class ApplicationSettings to read the path from the properties file.

# 5. Integração/Demonstração

It was added a new UI to the application, also we added a new menu deddicated for the warehouse management. For now, the
only has the option to import a warehouse plant, but it will be extended in the future.

When creating a new product, it is necessary to add his location in the warehouse. To do this, it will be necessary to
devleop a new functionality that will choose one of the available locations for the product. This functionality will be
implemented in the scope of US1001.

When configuring an AGV, it is necessary to add the location of the dock. So, here we have a point of connection
between the two parts of the application.
