US 4002
=======================================

## **Demo:**

As Project Manager, I want that the "AGVManager" component is enhanced with a basic FIFO algorithm to automatically assign tasks to AGVs.

## Acceptance Criteria:

* The general idea is that product orders reaching a certain state whose meaning is of "need to be prepared by an AGV" are added to a list. Then, following the FIFO algorithm orders are removed from the queue and assigned to available AGVs capable of performing the task that such order implies.
* Teams are free to propose a solution for that problem/issue. Notice that all team decisions must be well supported in light of business need and technical constraints.

## Client Answers:

* In US4002 it is required that the AGV Manager should support automatic assignment of orders to AGVs. In US2003 the Warehouse Employee will be able to assign any order to an AGV available. If the orders are being automatically assigned to an AGV (US4002)


#Analysis

The AGV Managager server should automatically associate **Orders** that are ready to be processed by **AGV**
and search for a free **AGV** by prioritizing the **FIFO** algorithm.

Each **Order** can only be associated with only one **AGV**, after an **AGV** is assigned
to an **Order** it can no longer process any other **Order** until it has completed processing
its current **Order**.

In this User Story, the user has no participation with the program. The server does everything automatically.

## Domain Model

![US4002DM](MD4002.svg)

## SSD

![US4002SSD](SSD4002.svg)

##Design

###General and Best Scenarion
Each time the server is up, the program will update the **AGV-Order** relation by
calling a service named **AssignOrderToAnAGVService**, this service will search all the **Orders**
that need to be processed by an **AGV**, and then it will search all available **AGVs**.

After this search, the program will organize the **Orders** by using the
**FIFO algorithm** and then the **Orders** will be associated by the available **AGVs**.

The Server will update the **AGV** and the **Order** database.

###Worst Scenario

If there are **Orders** that need to be processed by **AGVs** but all of them are occupied,
the program will inform the **User** that there is no **AGV** availabe to process an **Order**.

We think that only the **Warehouse Managers** should be the only ones who get this information, since
they're in charge of the **Warehouse** and the **AGV** management.

###Sequence Diagram
![US4002SD](SD4002.svg)

###Class Diagram
![US4002CD](CD4002.svg)

###Functionality Realization

We are using a layer structure design:

* Server:
    * Presentation:
        * TcpAgvProtocolServer
        * TcpAgvSrv
    * Thread:
        * AssignOrderToAnAGVService
* Domain:
    * ClientOrder
    * AGV
* Persistance
    * OrderRepository
    * JPAOrderRepository
    * AGVRepository
    * JPAAGVRepository

## Applied Techniques

* GRASI (Information Expert, Creator, Controller, Low Coupling (evaluative), High Cohesion (evaluative), Polymorphism, Pure Fabrication, Indirection, Protected Variations);
    + Information Expert - The service, since has a direct connection with the repositories, in this case, knows all domain concepts from this specific Use Case;
    + Creator, the UI creates the controller, and the controller creates all needed services;
    + Low Coupling and High Cohesion, since we are using a lot of structured layers, all with a specific meaning, we are applying this pattern aswell;
    + Polymorphism, since a domain concept object may have multiple different values;
    + Pure Fabrication, since there is only 1 of each type of class created, meaning, in case of the controller and the UI they are only created one time;
    + The other patterns already were explained by previous points;
* Tell, don't ask;
    + Basic pattern, has a similar function as "Keep it simple", since both patterns apply simple interaction between actor - UI and UI - controller;
* Single Responsibility Principle;
* Interface Segregation Principle;
* Intention Revealing Interfaces;
* DDD (Persistence Ignorance, Entity, Value Object, Domain Service, Aggregate, Domain Event, Observer, Events);
    + This pattern was introduced in EAPLI, where we started working with this pattern. It is very important to fully understand this pattern, since it makes an implementation of a domain business concept way easier (and makes it easier to understand to outside people), Entities, value objects, services... All are well explained in the Geral Domain model and the glossary, so I think there is no need to explain this here;
* Repositories pattern;
    + This pattern applies a persistance context using repositories to have an easier communication between the run time system, and a remote database, where it makes the operation between the same atomic and simple transactions;
* Services pattern;
    + This pattern applies both to the domain and the application layer, in this specific Use Case it wasn't used services in the domain layer only in the Application layer, as stated previously to make an easier interaction between CONTROLLER - SERVICE - REPOSITORY;

## Tests
