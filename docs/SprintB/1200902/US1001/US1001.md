# US1001
=======================================

# 1. Requisitos

As a Sales Clerk, I want to specify a new product for sale.

* Specify a new product. A product specification comprehends multiple attributes (cf. section 2.1).
  * a. A product might be manually created by a salesclerk by typing (or selecting) all the mandatory data required to be clientOrder by a customer.
  * b. Alternatively, products might be imported from a text file generated by an external system. Multiple text file formats need to be supported (e.g.: CSV, XML).
  * c. Imported products might have some missing information (e.g.: its warehouse location), which can be further added by the salesclerk.


# 2. Análise

## 2.1. System Sequence Diagram (SSD)

![US1001_SSD](US1001_SSD.svg)

## 2.2. Domain Model Excerpt (DM)

![US1001_DM](US1001_DM.svg)


# 3. Design

## 3.1. Sequence Diagram (SD)

![US1001_SD](US1001_SD.svg)

## 3.2. Class Diagram (CD)

![US1001_CD](US1001_CD.svg)

## 3.3. Padrões Aplicados

  * Information Expert
  * Tell, don't ask
  * Single Responsibility Principle
  * Interface Segregation Principle
  * Intention Revealing Interfaces
  * DDD (Persistence Ignorance, Entity, Value Object, Domain Service, Aggregate, Domain Event, Observer)
  * Factories
  * Repositories
  * GRASP (High cohesion, Low coupling)
  * Protected Variation
  * Dependency Inversion Principle
  
## 3.4. Testes

**Teste 1:** Verificar que é possível criar uma instância da classe Product **sem** production code.
        
    @Test
    public void ensureCanBuildProductWithoutProductionCode() {
        final Product subject = new ProductBuilder().withACategoryId(CATEGORY).coded(CODE).withAShortDescription(SHORT_DESCRIPTION).withAnExtendedDescription(EXTENDED_DESCRIPTION).withATechnicalDescription(TECHNICAL_DESCRIPTION).withABrandName(BRAND_NAME).withAReference(REFERENCE).withABarcode(BARCODE).withAPrice(PRICE).withASetOfPhotos(PHOTO_LIST).build();

        assertNotNull(subject);
    }

**Teste 2:** Verificar que é possível criar uma instância da classe Product **com** production code.
    
    @Test
    public void ensureCanBuildProduct() {
        final Product subject = new ProductBuilder().withACategoryId(CATEGORY).coded(CODE).withAShortDescription(SHORT_DESCRIPTION).withAnExtendedDescription(EXTENDED_DESCRIPTION).withATechnicalDescription(TECHNICAL_DESCRIPTION).withABrandName(BRAND_NAME).withAReference(REFERENCE).withABarcode(BARCODE).withAPrice(PRICE).withASetOfPhotos(PHOTO_LIST).withAProductionCode(PRODUCTION_CODE).build();

        assertNotNull(subject);
    }

**Teste 3:** Verificar que não é possível criar uma instância da classe Product com um internal code nulo.

    @Test
    void ensureCannotBuildProductWithCodeNull() {
        Exception exception = Assertions.assertThrows(IllegalArgumentException.class, () -> new ProductBuilder().withACategoryId(CATEGORY).coded(Code.valueOf("")).withAShortDescription(SHORT_DESCRIPTION).withAnExtendedDescription(EXTENDED_DESCRIPTION).withATechnicalDescription(TECHNICAL_DESCRIPTION).withABrandName(BRAND_NAME).withAReference(REFERENCE).withABarcode(BARCODE).withAPrice(PRICE).withASetOfPhotos(PHOTO_LIST).build());
        assertEquals("Code should neither be null nor empty", exception.getMessage());
    }

**Teste 4:** Verificar que não é possível criar uma instância da classe Product sem estar associada a uma categoria.

    @Test
    void ensureMustHaveCategoryId() {
        assertThrows(IllegalArgumentException.class, () -> new Product(null, CODE, SHORT_DESCRIPTION, EXTENDED_DESCRIPTION, TECHNICAL_DESCRIPTION, BRAND_NAME, REFERENCE, BARCODE, PRICE, PHOTO_LIST));
    }

**Teste 5:** Verificar que é possível atualizar os valores de uma instância da classe Product com uma nova pequena descrição.

    @Test
    void ensureCanChangeShortDescription() {
        final Product subject = buildProductWithProductionCode();

        final Description newInfo = Description.valueOf("Another short description");

        subject.update(CATEGORY_ID, CODE, newInfo, EXTENDED_DESCRIPTION, TECHNICAL_DESCRIPTION, BRAND_NAME, REFERENCE, BARCODE, PRICE, PHOTO_LIST, PRODUCTION_CODE);
    }

**Teste 6:** Verificar que é possível criar uma instância da classe Bin.

    @Test
    public void ensureCanBuildBin() {
        final Bin subject = new BinBuilder().withABinLocation(BIN_LOCATION).withAProductId(PRODUCT_ID).build();
    }

**Teste 7:** Verificar que não é possível criar uma instância da classe Bin com um product ID nulo.

    @Test
    void ensureCannotBuildBinWithProductIdNull() {
        Exception exception = Assertions.assertThrows(IllegalArgumentException.class, () -> new BinBuilder().withABinLocation(BIN_LOCATION).withAProductId(Long.valueOf("")));
        assertEquals("For input string: \"\"", exception.getMessage());
    }

**Teste 8:** Verificar que não é possível criar uma instância da classe Bin com uma localização nula.

    @Test
    void ensureMustHaveLocation() {
        assertThrows(IllegalArgumentException.class, () -> new Bin(null, PRODUCT_ID));
    }

**Teste 9:** Verificar que é possível atualizar os valores de uma instância da classe Bin com uma nova localização.

    @Test
    void ensureCanChangeLocation() {
        final Bin subject = buildBin();

        final BinLocation newInfo = BinLocation.valueOf(2,2,2);

        subject.update(newInfo, PRODUCT_ID);
    }


# 4. Implementação

## RegisterProductController

    @UseCaseController
    public class RegisterProductController {
    
        private Product product;
        private final AuthorizationService authorizationService = AuthzRegistry.authorizationService();
        private final RegisterProductService registerProductService = new RegisterProductService();
        private final ViewAllCategoriesService viewAllCategoriesService = new ViewAllCategoriesService();
        private final GenerateBinService generateBinService = new GenerateBinService();
        private final SearchWarehouseService service = new SearchWarehouseService();
    
        public Product registerProductWithoutProductionCode(final int option, final Code code, final Description shortDescription, final Description extendedDescription, final Description technicalDescription, final BrandName brandName, final Reference reference, final Barcode barcode, final Money price, final List<String> photo) throws IOException {
            authorizationService.ensureAuthenticatedUserHasAnyOf(BaseRoles.SALES_CLERK, BaseRoles.POWER_USER);
    
            this.product = registerProductService.registerProductWithoutProductionCode(findCategoryId(option), code, shortDescription, extendedDescription, technicalDescription, brandName, reference, barcode, price, convertByteIntoPhoto(photo));
    
            return product;
        }
    
        public Product registerProductWithProductionCode(final int option, final Code code, final Description shortDescription, final Description extendedDescription, final Description technicalDescription, final BrandName brandName, final Reference reference, final Barcode barcode, final Money price, final List<String> photo, final ProductionCode productionCode) throws IOException {
            authorizationService.ensureAuthenticatedUserHasAnyOf(BaseRoles.SALES_CLERK, BaseRoles.POWER_USER);
    
            this.product = registerProductService.registerProductWithProductionCode(findCategoryId(option), code, shortDescription, extendedDescription, technicalDescription, brandName, reference, barcode, price, convertByteIntoPhoto(photo), productionCode);
    
            return product;
        }
    
        public ProductDTO getProductDTO() {
            return product.toDTO();
        }
    
        public List<CategoryDTO> getCategoryDTOList() {
            return viewAllCategoriesService.getAllCategories();
        }
    
        private Long findCategoryId(int option) {
            CategoryDTO categoryDTO = getCategoryDTOList().get(option - 1);
    
            return viewAllCategoriesService.getCategoryId(categoryDTO);
        }
    
        public boolean validateAndVerifyPath(String path) {
            String extension = FilenameUtils.getExtension(path);
    
            if (extension.equals("png") || extension.equals("jpg") || extension.equals("svg")) {
                File file = new File(path);
    
                if (file.exists() && !file.isDirectory()) {
                    return true;
    
                } else {
                    throw new IllegalStateException("Invalid path! The path introduced does not exist.");
                }
            } else {
                throw new IllegalStateException("Invalid file format! Please enter a .png, .jpg or .svg file.");
            }
        }
    
        private List<Photo> convertByteIntoPhoto(List<String> sList) throws IOException {
            List<Photo> photoList = new ArrayList<>();
    
            for (byte[] aByte : registerProductService.validatePhotoPath(sList)) {
                Photo p = Photo.valueOf(aByte);
                photoList.add(p);
            }
    
            return photoList;
        }
    
        public ShelfDTO getBinLocation() {
            return generateBinService.generateBin(product.identity());
        }
    
        public boolean verifyWarehouseImported() {
            if (service.getWarehouse() == null) return false;
            else return true;
        }
    }


## Product

    @Entity
    public class Product implements AggregateRoot<Long>, DTOable<ProductDTO>, Representationable {

        private static final long serialVersionUID = 210702L;

        @Id
        @GeneratedValue(strategy = GenerationType.AUTO)
        private Long productId;
    
        @Version
        private Long version;
    
        @JoinColumn(nullable = false, name = "category_id")
        private Long categoryId;
    
        @Column(unique = true, nullable = false)
        private Code code;
    
        @AttributeOverride(name = "value", column = @Column(name = "short_description"))
        @Column(nullable = false)
        private Description shortDescription;
    
        @AttributeOverride(name = "value", column = @Column(name = "extended_description"))
        @Column(nullable = false)
        private Description extendedDescription;
    
        @AttributeOverride(name = "value", column = @Column(name = "technical_description"))
        @Column(nullable = false)
        private Description technicalDescription;
    
        @Column(nullable = false)
        private BrandName brandName;
    
        @Column(nullable = false)
        private Reference reference;
    
        @Column(nullable = false)
        private Barcode barcode;
    
        @Column(nullable = false)
        private Money price;
    
        @OneToMany(cascade = CascadeType.ALL)
        private List<Photo> photoList;
    
        @Column
        private ProductionCode productionCode;
    
        protected Product() {
            // For ORM only
        }
    
        public Product(final Long categoryId, final Code code, final Description shortDescription, final Description extendedDescription, final Description technicalDescription, final BrandName brandName, final Reference reference, final Barcode barcode, final Money price, final List<Photo> photoList) {
            Preconditions.noneNull(categoryId, code, shortDescription, extendedDescription, technicalDescription, brandName, reference, barcode, price, photoList);
    
            this.categoryId = categoryId;
            this.code = code;
            this.shortDescription = shortDescription;
            this.extendedDescription = extendedDescription;
            this.technicalDescription = technicalDescription;
            this.brandName = brandName;
            this.reference = reference;
            this.barcode = barcode;
            this.price = price;
            this.photoList = photoList;
        }
    
        public Product(final Long categoryId, final Code code, final Description shortDescription, final Description extendedDescription, final Description technicalDescription, final BrandName brandName, final Reference reference, final Barcode barcode, final Money price, final List<Photo> photoList, final ProductionCode productionCode) {
            Preconditions.noneNull(categoryId, code, shortDescription, extendedDescription, technicalDescription, brandName, reference, barcode, price, photoList);
    
            this.categoryId = categoryId;
            this.code = code;
            this.shortDescription = shortDescription;
            this.extendedDescription = extendedDescription;
            this.technicalDescription = technicalDescription;
            this.brandName = brandName;
            this.reference = reference;
            this.barcode = barcode;
            this.price = price;
            this.photoList = photoList;
            this.productionCode = productionCode;
        }
    
        @Override
        public Long identity() {
            return this.productId;
        }
    
        @Override
        public boolean sameAs(final Object other) {
            if (!(other instanceof Product)) {
                return false;
            }
    
            final Product that = (Product) other;
            if (this == that) {
                return true;
            }
    
            return identity().equals(that.identity()) && categoryId.equals(that.categoryId)
                    && code.equals(that.code)
                    && shortDescription.equals(that.shortDescription)
                    && extendedDescription.equals(that.extendedDescription)
                    && technicalDescription.equals(that.technicalDescription)
                    && brandName.equals(that.brandName)
                    && reference.equals(that.reference)
                    && barcode.equals(that.barcode)
                    && price.equals(that.price)
                    && photoList.equals(that.photoList);
        }
    
        @Override
        public <R> R buildRepresentation(RepresentationBuilder<R> builder) {
            builder.startObject("Product").withProperty("category ID", String.valueOf(categoryId))
                    .withProperty("code", String.valueOf(code))
                    .withProperty("short description", shortDescription)
                    .withProperty("extended description", extendedDescription)
                    .withProperty("technical description", technicalDescription)
                    .withProperty("brand name", String.valueOf(brandName))
                    .withProperty("reference", String.valueOf(reference))
                    .withProperty("barcode", String.valueOf(barcode))
                    .withProperty("price", price)
                    .withProperty("photoList", String.valueOf(photoList))
                    .withProperty("production code", String.valueOf(productionCode));
    
            return builder.build();
        }

        @Override
        public boolean equals(Object o) {
            return DomainEntities.areEqual(this, o);
        }
    
        @Override
        public int hashCode() {
            return DomainEntities.hashCode(this);
        }
    
        @Override
        public ProductDTO toDTO() {
            return new ProductDTO(categoryId.toString(), code.toString(), shortDescription.toString(), extendedDescription.toString(), brandName.toString(), reference.toString(), price);
        }
    
        private void changeCategory(final Long categoryId) {
            if (categoryId == null) {
                throw new IllegalArgumentException();
            }
            this.categoryId = categoryId;
        }
    
        private void changeCode(final Code code) {
            if (code == null) {
                throw new IllegalArgumentException();
            }
            this.code = code;
        }

        private void changeShortDescription(final Description shortDescription) {
            if (shortDescription == null) {
                throw new IllegalArgumentException();
            }
            this.shortDescription = shortDescription;
        }

        private void changeExtendedDescription(final Description extendedDescription) {
            if (extendedDescription == null) {
                throw new IllegalArgumentException();
            }
            this.extendedDescription = extendedDescription;
        }

        private void changeTechnicalDescription(final Description technicalDescription) {
            if (technicalDescription == null) {
                throw new IllegalArgumentException();
            }
            this.technicalDescription = technicalDescription;
        }

        private void changeBrandName(final BrandName brandName) {
            if (brandName == null) {
                throw new IllegalArgumentException();
            }
            this.brandName = brandName;
        }

        private void changeReference(final Reference reference) {
            if (reference == null) {
                throw new IllegalArgumentException();
            }
            this.reference = reference;
        }

        private void changeBarcode(final Barcode barcode) {
            if (barcode == null) {
                throw new IllegalArgumentException();
            }
            this.barcode = barcode;
        }

        private void changePrice(final Money price) {
            if (price == null) {
                throw new IllegalArgumentException();
            }
            this.price = price;
        }

        private void changePhoto(final List<Photo> photo) {
            if (photo == null) {
                throw new IllegalArgumentException();
            }
            this.photoList = photo;
        }

        private void changeProductionCode(final ProductionCode productionCode) {
            if (productionCode == null) {
                throw new IllegalArgumentException();
            }
            this.productionCode = productionCode;
        }

        public void update(final Long categoryId, final Code code, final Description shortDescription, final Description extendedDescription, final Description technicalDescription, final BrandName brandName, final Reference reference, final Barcode barcode, final Money price, final List<Photo> photo, final ProductionCode productionCode) {
            Preconditions.noneNull(categoryId, code, shortDescription, extendedDescription, technicalDescription, brandName, reference, barcode, price, photo);

            changeCategory(categoryId);
            changeCode(code);
            changeShortDescription(shortDescription);
            changeExtendedDescription(extendedDescription);
            changeTechnicalDescription(technicalDescription);
            changeBrandName(brandName);
            changeReference(reference);
            changeBarcode(barcode);
            changePrice(price);
            changePhoto(photo);
            changeProductionCode(productionCode);
        }

        public Money price() {
            return this.price;
        }
    }

## ViewAllCategoriesService

    @ApplicationService
    public class ViewAllCategoriesService {

        private final CategoryRepository categoryRepository = PersistenceContext.repositories().categories();

        public List<CategoryDTO> getAllCategories() {
            List<Category> categoryList = categoryRepository.findAll();

            List<CategoryDTO> categoryDTOS = new ArrayList<>();

            for(Category category : categoryList) {
                categoryDTOS.add(category.toDTO());
            }

            return categoryDTOS;
        }

        public Long getCategoryId(CategoryDTO categoryDTO) {
            return categoryRepository.findByCodeAndReturnId(categoryDTO.getAlphaNumericCode());
        }
    }



## RegisterPhotoService

    @ApplicationService
    public class RegisterProductService {

        private final ProductRepository productRepository = PersistenceContext.repositories().products();
    
        public Product registerProductWithoutProductionCode(final Long categoryId, final Code code, final Description shortDescription, final Description extendedDescription, final Description technicalDescription, final BrandName brandName, final Reference reference, final Barcode barcode, final Money price, final List<Photo> photoList) throws IOException {
            return productRepository.save(new Product(categoryId, code, shortDescription, extendedDescription, technicalDescription, brandName, reference, barcode, price, photoList));
        }
    
        public Product registerProductWithProductionCode(final Long categoryId, final Code code, final Description shortDescription, final Description extendedDescription, final Description technicalDescription, final BrandName brandName, final Reference reference, final Barcode barcode, final Money price, final List<Photo> photoList, final ProductionCode productionCode) {
            return productRepository.save(new Product(categoryId, code, shortDescription, extendedDescription, technicalDescription, brandName, reference, barcode, price, photoList, productionCode));
        }
    
        public byte[][] validatePhotoPath(List<String> pathPhotoList) throws IOException {
    
            byte[][] byteMatrix = new byte[pathPhotoList.size()][];
            int index = 0;
    
            for (String s : pathPhotoList) {
                File file = new File(s);
                byte[] picInBytes = new byte[(int) file.length()];
                FileInputStream fileInputStream = new FileInputStream(file);
                fileInputStream.read(picInBytes);
                fileInputStream.close();
    
                byteMatrix[index] = picInBytes;
                index++;
            }
    
            return byteMatrix;
        }
    }

## Bin

    @Entity
    public class Bin implements AggregateRoot<Long>, DTOable<BinDTO>, Representationable {
    
        @Id
        @GeneratedValue(strategy = GenerationType.AUTO)
        private Long binId;
    
        @Column(nullable = false)
        private BinLocation binLocation;
    
        @JoinColumn(nullable = false, name = "product_id")
        private Long productId;
    
        protected Bin() {
            // For ORM only
        }
    
        public Bin(final BinLocation binLocation, final Long productId) {
            Preconditions.noneNull(binLocation, productId);
    
            this.binLocation = binLocation;
            this.productId = productId;
        }
    
        @Override
        public Long identity() {
            return this.binId;
        }
    
        @Override
        public boolean sameAs(Object other) {
            if (!(other instanceof Bin)) {
                return false;
            }
    
            final Bin that = (Bin) other;
            if (this == that) {
                return true;
            }
    
            return identity().equals(that.identity())
                    && binLocation.equals(that.binLocation)
                    && productId.equals(that.productId);
        }
    
        @Override
        public <R> R buildRepresentation(RepresentationBuilder<R> builder) {
            builder.startObject("Bin").withProperty("bin location", String.valueOf(binLocation))
                    .withProperty("product ID", String.valueOf(productId));
    
            return builder.build();
        }
    
        @Override
        public boolean equals(Object o) {
            return DomainEntities.areEqual(this, o);
        }
    
        @Override
        public int hashCode() {
            return DomainEntities.hashCode(this);
        }
    
        @Override
        public BinDTO toDTO() {
            return new BinDTO(binLocation.toString(), productId.toString());
        }
    
        private void changeBinLocation(final BinLocation binLocation) {
            if (binLocation == null) {
                throw new IllegalArgumentException();
            }
            this.binLocation = binLocation;
        }
    
        private void changeProduct(final Long productId) {
            if (productId == null) {
                throw new IllegalArgumentException();
            }
            this.productId = productId;
        }
    
        public void update(final BinLocation binLocation, final Long productId) {
            Preconditions.noneNull(binLocation, productId);
    
            changeBinLocation(binLocation);
            changeProduct(productId);
        }
    }

## BinLocation

    @Embeddable
    public class BinLocation implements ValueObject {
    
        private final int aisleIdentifier;
        private final int rowIdentifier;
        private final int shelfIdentifier;
    
        public BinLocation(int aisleIdentifier, int rowIdentifier, int shelfIdentifier) {
            Preconditions.nonNegative(aisleIdentifier);
            Preconditions.nonNegative(rowIdentifier);
            Preconditions.nonNegative(shelfIdentifier);
    
    
            this.aisleIdentifier = aisleIdentifier;
            this.rowIdentifier = rowIdentifier;
            this.shelfIdentifier = shelfIdentifier;
    
        }
    
        protected BinLocation() {
            //for ORM purposes only
            this.aisleIdentifier = 0;
            this.rowIdentifier = 0;
            this.shelfIdentifier = 0;
        }
    
        public static BinLocation valueOf(int shelfId, int rowId, int aisleId) {
            return new BinLocation(shelfId, rowId, aisleId);
        }
    
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            BinLocation that = (BinLocation) o;
            return this.aisleIdentifier == that.aisleIdentifier && this.rowIdentifier == that.rowIdentifier && this.shelfIdentifier == that.shelfIdentifier;
        }
    }

## GenerateBinService

    @ApplicationService
    public class GenerateBinService {
    private Bin bin;
    
        private final SearchWarehouseService service = new SearchWarehouseService();
        private final AssignShelfService assignShelfService = new AssignShelfService(service.getWarehouse());
        private final AuthorizationService authz = AuthzRegistry.authorizationService();
        private final BinRepository binRepository = PersistenceContext.repositories().bins();
    
        public ShelfDTO generateBin(final Long productId) {
            authz.ensureAuthenticatedUserHasAnyOf(BaseRoles.SALES_CLERK);
    
            ShelfDTO shelfDTO = assignShelfService.assignShelf();
            Bin bin = new Bin(BinLocation.valueOf(shelfDTO.shelf(), shelfDTO.row(), shelfDTO.aisle()), productId);
            binRepository.save(bin);
    
            return shelfDTO;
        }
    }


# 5. Integração/Demonstração

*Nesta secção a equipa deve descrever os esforços realizados no sentido de integrar a funcionalidade desenvolvida com as restantes funcionalidades do sistema.*


# 6. Observações
