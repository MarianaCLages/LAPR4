US1005
=======================================


# 1. Requisitos

As Warehouse Employee, I want to configure the AGVs available on the warehouse.



* Create a new product category. A category is characterized by an alphanumeric code, a description, and, optionally, a reference to its super-category.
  
  
**Note** : According to some Client asnwers that exist in the forum, the category doesn't need to have a reference to a super category! So we are going to procced in this Use Case with that in mind.

<br>

**Demo**

- Demo 1.1 - Create a new product category

    + In order to make this demo happen, we first have to analyze what is demanded in this Use Case scenario, and what the client has said in the forum.
    
    + We are going to make a feature in our program that is going to create a new product category with specific information introduced by the Actor, the Sales Clerk.
    
    + This information must obey some specific rules/patterns, like, the code: not empty alphanumeric code with at 10 chars maximum, and the description: not empty with a minimum of 20 chars and 50 chars maximum;
    
    + The same information cannot be empty and must carry a meaning in the business concept, so we must be careful when the same is introduced in the system.

# 2. Análise

## Brief approach


Before making any rash decisions, we must see the whole scenario, since the moment that the feature starts until its end. From the client answers it's possible to deduce that:
* In the beginning, the system is going to ask the actor the necessary information, which is mandatory, in order to create a category. The actor must obey the rules specified by the client when introducing this information.

<br>

* Afterwards, the system is going to create the category with the information entered by the Actor.

<br> 

* In the end, the system is going to show the created category to the Actor and aks for confirmation in order to save it (persist it).

**Note : This is all information that the client provided in the forum.**

<br>

In order to represent this way of thinking better, we decided to create some artifacts in order to "illustrate" the Use Case itself.

## DM (Domain Model)

The first artifact done was the Domain Model, an abstract illustration of the business concept of this Use Case.

![US1005MD](US1005_DM.svg)

The same artifact applies the DDD pattern in order to illustrate the business concept. Shows all domain concepts relevant to this Use Case, making a clear representation of all business concepts that are used in this Use Case scenario.

## SSD (System Sequence Diagram)

The second artifact done in this section, analysis, was the System Sequence Diagram, where it clearly specifies the interaction between the System and the Actor, in this case, the Sales Clerk.

![US1005SSD](US1005_SSD.svg)

As we can see in the diagram, the exact interaction between the actor and the system is illustrated. The system is going to ask the Actor the mentioned information and then confirm if the actor wishes to save the category that was created in the moment.

##Conclusion

After this analysis, now we have all the information gather to start the design part, the design artifacts.

# 3. Design

###Brief approach

<br>

<p> Now we can start the "implementation", in other words, the design of the system itself, where we "draw" our ideias and make a "sketch" of the same. </p>

### SD (Sequence Diagram)

<p> The first diagram created in this section was the Sequence Diagram, where we illustrate how the system operates in this Use Case. </p>

![US1005SD](US1005_SD.svg)

 <p> In order to analyze this diagram better, I would recommend the reader to open the file and see step by step how the system operates, that is exactly the same as stated previously in the analysis.
Now we know how the system will operate, step by step, and we can add additional artifacts to illustrate the system working. </p>

As we can see here, after the confirmation from the Actor, the category is persisted in order to be used by other Actors in other Use Cases, like, creating a product.

## 3.1. Realização da Funcionalidade

We are using a layer structure design.:
- Domain Layer:
    - Category
- Application Layer:
    - RegisterCategoryController
    - RegisterCategoryController
- Builder Layer:
    - CategoryBuilder
- Repository Layer:
    - CategoryRepository

## 3.2. Diagrama de Classes

This artifact, as stated previously, it's complementary to the design part, only serves to make it richer.

![US1002CD](US1005_CD.svg)

## 3.3. Padrões Aplicados

* GRASI (Information Expert, Creator, Controller, Low Coupling (evaluative), High Coesion(evaluative), Polymorphism, Pure Fabrication, Indirection, Protected Variations);
* Tell, don't ask;
* Single Responsibility Principle;
* Interface Segregation Principle;
* Intention Revealing Interfaces;
* DDD (Persistence Ignorance, Entity, Value Object, Domain Service, Aggregate, Domain Event, Observer, Events)
* Repositories pattern;
* Services pattern;
* Builder pattern;  
* Dependency Inversion Principle.

This are the mainly patterns applied while developing the artifacts and a valid approach to the Use Case itself.

## 3.4. Testes

**Teste 1:** Ensure a Category can be created with valid information.

    @Test
    public void ensureCategoryWithDescriptionAndCode() {

        private static final Description DESCRIPTION_NAME = Description.valueOf("A valid description for tests!");
        private static final AlphaNumericCode ALPHA_NUMERIC_CODE = AlphaNumericCode.valueOf("C0001");

        new Category(DESCRIPTION_NAME, ALPHA_NUMERIC_CODE);
        assertTrue(true);
    }

**Teste 2:** Verify if a exception is raised when the description is null.

        @org.junit.Test(expected = IllegalArgumentException.class)
         public void ensureMustHaveDescription() {
         new Category(null, ALPHA_NUMERIC_CODE);
        }

**Teste 3:** Verify if a exception is raised when the alpha code is null.

         @org.junit.Test(expected = IllegalArgumentException.class)
          public void ensureMustHaveCode() {
          new Category(DESCRIPTION_NAME, null);
         }

**Teste 4:** Ensure can not change the alpha code to a null value.

        @org.junit.Test(expected = IllegalArgumentException.class)
            public void ensureCannotChangeCodeToNull() {
            final Category subject = buildCategory();

            final AlphaNumericCode newInfo = null;

             subject.update(newInfo, DESCRIPTION_NAME);
         }

**Teste 5:** Ensure can not change the description value.

         @org.junit.Test(expected = IllegalArgumentException.class)
            public void ensureCannotChangeDescriptionToNull() {
            final Category subject = buildCategory();

            final Description newInfo = null;

            subject.update(ALPHA_NUMERIC_CODE, newInfo);
         }

**Teste 6:** Ensure can change the alpha code value.

            @Test
            public void ensureCanChangeCode() {
                final Category subject = buildCategory();

                final AlphaNumericCode newInfo = AlphaNumericCode.valueOf("C0003");

                subject.update(newInfo, DESCRIPTION_NAME);
             }

**Teste 7:** Ensure the category builder can build a category with a valid description, and a valid alpha code


        @Test
         public void ensureCanBuildCategoryWithDescriptionAndCode(){
           final Category subject = new CategoryBuilder().withADescription(DESCRIPTION).coded(ALPHA_NUMERIC_CODE).build();

            assertNotNull(subject);
        }

**Teste 8:** Ensure the category builder can not build a category with a invalid description, and a valid alpha code

        @Test
        public void ensureCannotBuildCategoryWithDescriptionNull() {
            Exception e = Assertions.assertThrows(IllegalArgumentException.class, () -> new CategoryBuilder().withADescription(Description.valueOf("")).coded(ALPHA_NUMERIC_CODE).build());
            assertEquals("Description should neither be null nor empty",e.getMessage());

        }

**Teste 9:** Ensure the category builder can not build a category with valid description, and a invalid alpha code


        @Test
         public void ensureCannotBuildCategoryWithCodeNull() {
          Exception e = Assertions.assertThrows(IllegalArgumentException.class, () -> new CategoryBuilder().withADescription(DESCRIPTION).coded(AlphaNumericCode.valueOf("")).build());
          assertEquals("AlphaNumeric code should neither be null nor empty",e.getMessage());
        }

# 4. Implementação

Since the requirements of this Use Case was able to register a new category, we opted to make a service to register the category, this way we can abstract the Controller, Application Layer, from the Repository Layer, applying this way the best as we can the Grap Pattern.

# 5. Integração/Demonstração

It was added a new UI to the application, also we added a new menu dedicated for the category management. For now, the
only has the option is to register a new category, but it will be extended in the future.

<br>

This is an important Use Case, since a lot more Use Cases depend on this one, like the Use Case where a product will be registered. If there weren't categories in the system, it wouldn't be possible to register products, which would effect aswell the Use case where a order must be registered by a Sales Clerk, the same actor as this Use case.

# 6. Observações

I think our interpretation of the Use case was the best as possible, since we treated all possible input making it impossible to have "incorrect data" (all data must be according to the patterns specified by the client), and the way we show the category created is in a great quality, since we use the DTO pattern and instead of sending the domain concept object to the UI we send a DTO of the same, only having the necessary information to the actor.